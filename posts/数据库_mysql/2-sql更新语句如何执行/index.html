<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>2. sql更新语句执行过程  - </title><meta name="Description" content="这是我的全新 Hugo 网站"><meta property="og:title" content="2. sql更新语句执行过程 " />
<meta property="og:description" content="一、 参考 mysql实战 binlog的类型 redolog的持久化方式 MySQL写优化,关于 innodb_flush_log_at_trx_commit 和 sync_binlog sync_binlog MySQL - binlog日志简介及设置 二、引言 一条查" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzthewind.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql/2-sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C/" />
<meta property="og:image" content="https://yzthewind.github.io/logo.png"/>
<meta property="article:published_time" content="2020-07-06T11:00:00+08:00" />
<meta property="article:modified_time" content="2020-07-06T11:00:00+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://yzthewind.github.io/logo.png"/>

<meta name="twitter:title" content="2. sql更新语句执行过程 "/>
<meta name="twitter:description" content="一、 参考 mysql实战 binlog的类型 redolog的持久化方式 MySQL写优化,关于 innodb_flush_log_at_trx_commit 和 sync_binlog sync_binlog MySQL - binlog日志简介及设置 二、引言 一条查"/>
<meta name="application-name" content="一曲广陵散">
<meta name="apple-mobile-web-app-title" content="一曲广陵散"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://yzthewind.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql/2-sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C/" /><link rel="prev" href="https://yzthewind.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql/1-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" /><link rel="next" href="https://yzthewind.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql/3-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "2. sql更新语句执行过程 ",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/yzthewind.github.io\/posts\/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql\/2-sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C\/"
        },"genre": "posts","keywords": "mysql","wordcount":  10822 ,
        "url": "https:\/\/yzthewind.github.io\/posts\/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql\/2-sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C\/","datePublished": "2020-07-06T11:00:00+08:00","dateModified": "2020-07-06T11:00:00+08:00","publisher": {
            "@type": "Organization",
            "name": "yz"},"author": {
                "@type": "Person",
                "name": "yz"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title=""><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title=""><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">2. sql更新语句执行过程 </h1><h2 class="single-subtitle">mysql</h2><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>yz</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E5%AD%98%E5%82%A8/"><i class="far fa-folder fa-fw"></i>存储</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2020-07-06">2020-07-06</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 10822 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 22 分钟&nbsp;</div>
        </div><div class="featured-image"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/mysql/2-sql%e6%9b%b4%e6%96%b0%e8%af%ad%e5%8f%a5%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c.jpg"
        data-srcset="/images/mysql/2-sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C.jpg, /images/mysql/2-sql%e6%9b%b4%e6%96%b0%e8%af%ad%e5%8f%a5%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c.jpg 1.5x, /images/mysql/2-sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C.jpg 2x"
        data-sizes="auto"
        alt="/images/mysql/2-sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C.jpg"
        title="/images/mysql/2-sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C.jpg" /></div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#一-参考">一、 参考</a></li>
    <li><a href="#二引言">二、引言</a></li>
    <li><a href="#三更新语句的流程概要">三、更新语句的流程概要</a>
      <ul>
        <li><a href="#31-连接器">3.1 连接器</a></li>
        <li><a href="#32-查询缓存">3.2 查询缓存</a></li>
        <li><a href="#33-分析器">3.3 分析器</a></li>
        <li><a href="#34-优化器">3.4 优化器</a></li>
        <li><a href="#35-执行器">3.5 执行器</a></li>
        <li><a href="#36-更新语句的不同之处">3.6 更新语句的不同之处</a></li>
      </ul>
    </li>
    <li><a href="#四-redo-log">四、 redo log</a>
      <ul>
        <li><a href="#41-孔乙己的启示">4.1 孔乙己的启示</a></li>
        <li><a href="#42-wal-技术">4.2 WAL 技术</a></li>
        <li><a href="#43--写入模式">4.3  写入模式</a></li>
        <li><a href="#44-redolog的总结">4.4 redolog的总结</a></li>
      </ul>
    </li>
    <li><a href="#五-binlog">五、 binlog</a>
      <ul>
        <li><a href="#51-为什么会有两份日志呢">5.1 为什么会有两份日志呢?</a></li>
        <li><a href="#52-binlog-和-redolog的不同之处">5.2 binlog 和 redolog的不同之处</a></li>
        <li><a href="#53-内部更新流程">5.3 内部更新流程</a></li>
        <li><a href="#54-redolog的两阶段提交">5.4 redolog的两阶段提交</a></li>
        <li><a href="#55-恢复临时库的场景">5.5 恢复临时库的场景</a></li>
        <li><a href="#56-binlog总结">5.6 binlog总结</a></li>
      </ul>
    </li>
    <li><a href="#六涉及参数">六、涉及参数</a>
      <ul>
        <li><a href="#61-binlog_format">6.1 binlog_format</a></li>
        <li><a href="#62-sync_binlog">6.2 sync_binlog</a></li>
        <li><a href="#63-innodb_flush_log_at_trx_commit">6.3 innodb_flush_log_at_trx_commit</a></li>
        <li><a href="#64-expire_logs_daysbinlog_expire_logs_seconds">6.4 expire_logs_days/binlog_expire_logs_seconds</a></li>
        <li><a href="#65-log_bin">6.5 log_bin</a></li>
      </ul>
    </li>
    <li><a href="#七问题与解答">七、问题与解答</a>
      <ul>
        <li><a href="#71-问题">7.1 问题</a></li>
        <li><a href="#72-解答">7.2 解答</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><hr>
<p> </p>
<h2 id="一-参考">一、 参考</h2>
<p> </p>
<blockquote>
<p><a href="https://time.geekbang.org/column/intro/139" target="_blank" rel="noopener noreffer">mysql实战</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/binary-log-setting.html" target="_blank" rel="noopener noreffer">binlog的类型</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit" target="_blank" rel="noopener noreffer">redolog的持久化方式</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/wenniuwuren/article/details/89265251" target="_blank" rel="noopener noreffer">MySQL写优化,关于 innodb_flush_log_at_trx_commit 和 sync_binlog</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#sysvar_sync_binlog" target="_blank" rel="noopener noreffer">sync_binlog</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/hongdada/p/10983768.html" target="_blank" rel="noopener noreffer">MySQL - binlog日志简介及设置</a></p>
</blockquote>
<hr>
<p> </p>
<h2 id="二引言">二、引言</h2>
<p> </p>
<p>一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎</p>
<p>那么，一条更新语句的执行流程又是怎样的呢？</p>
<p> </p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql">
<span class="k">use</span> <span class="n">D</span><span class="p">;</span>

<span class="k">create</span> <span class="k">table</span> <span class="nf">T</span><span class="p">(</span><span class="n">ID</span> <span class="kt">int</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span> <span class="n">c</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">insert</span> <span class="k">into</span> <span class="n">T</span> <span class="k">values</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>

<span class="c1"># (1) 查看插入数据
</span><span class="c1"></span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">T</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1"># 返回值
</span><span class="c1"></span>
<span class="o">+----+------+</span>
<span class="o">|</span> <span class="n">ID</span> <span class="o">|</span> <span class="n">c</span>    <span class="o">|</span>
<span class="o">+----+------+</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span>   <span class="mi">22</span> <span class="o">|</span>
<span class="o">+----+------+</span>

<span class="c1"># （2）更新具体记录
</span><span class="c1"></span><span class="k">update</span> <span class="n">T</span> <span class="kt">set</span> <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1"># 返回值
</span><span class="c1"></span><span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="n">row</span> <span class="nf">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">01</span> <span class="n">sec</span><span class="p">)</span>
<span class="n">Rows</span> <span class="n">matched</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Changed</span><span class="p">:</span> <span class="mi">1</span>  <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>

<span class="c1"># （3）修改后的结果
</span><span class="c1"></span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">T</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1"># 返回值
</span><span class="c1"></span><span class="o">+----+------+</span>
<span class="o">|</span> <span class="n">ID</span> <span class="o">|</span> <span class="n">c</span>    <span class="o">|</span>
<span class="o">+----+------+</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span>   <span class="mi">23</span> <span class="o">|</span>
<span class="o">+----+------+</span>

</code></pre></div><p> </p>
<hr>
<p> </p>
<h2 id="三更新语句的流程概要">三、更新语句的流程概要</h2>
<p> </p>
<p> </p>
<h3 id="31-连接器">3.1 连接器</h3>
<p> </p>
<p>执行语句前要先连接数据库，这是连接器的工作</p>
<p> </p>
<h3 id="32-查询缓存">3.2 查询缓存</h3>
<p> </p>
<p>在一个表上有更新的时候，跟这个表有关的查询缓存会失效，</p>
<p>例如上面的语句会将把表 <code>T</code> 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因</p>
<p> </p>
<p>🔖问：为什么更新的时候要把所有的查询缓存清空呢，只删掉更新的那些不行吗？</p>
<p>📝答：没设计好</p>
<p> </p>
<p>🔖问：更新语句应该是在分析器以后才能确定表名的吧。那它怎么在这之前去清空该表的缓存的呢？</p>
<p>📝答：在之前是查缓存，执行语句以后才更新（失效）缓存</p>
<p> </p>
<p>🔖问：写内存的时候查询到的数据是不是最新的数据？如果写入内存成功，<code>redolog，binlog</code>失败了，会不会造成读到这个非法数据呢？</p>
<p>📝答：不会，事务没提交呢，<code>MVCC</code>会让别的线程看不到这个内存的修改的</p>
<p> </p>
<h3 id="33-分析器">3.3 分析器</h3>
<p> </p>
<p>分析器会通过词法和语法解析知道这是一条更新语句</p>
<p> </p>
<h3 id="34-优化器">3.4 优化器</h3>
<p> </p>
<p>优化器决定要使用 <code>ID</code> 这个索引</p>
<p> </p>
<h3 id="35-执行器">3.5 执行器</h3>
<p> </p>
<p>执行器负责具体执行，找到这一行，然后更新</p>
<p> </p>
<h3 id="36-更新语句的不同之处">3.6 更新语句的不同之处</h3>
<p> </p>
<p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块: <code>redo log</code> （重做日志） 、 <code>binlog</code> (归档日志)</p>
<p> </p>
<p>🔖问： <code>update</code>后先写入内存，然后写<code>redo log</code>，那么写入的这条数据在内存中的驻留时间是怎么处理的？是<code>redo log</code>写入磁盘后从内存中删除吗？</p>
<p>📝答： 不会删除，除非内存不够用。不过在数据从内存删除之前，系统会保证它会被更新到磁盘数据上</p>
<p> </p>
<p>🔖问：任何事务如果在回滚的时候系统异常重启了或者回滚操作失败了， 那是不是就导致数据状态可能不一致？ 这样情况会发生吗？ 如果发生了怎么避免？</p>
<p>📝答： 没问题的， 回滚中系统异常重启，重启后会继续回滚， 是通过扫描<code>redo log</code>状态来发现的</p>
<p> </p>
<p>🔖问：更新完内存以后，<code>mysql </code>会直接返回给客户端吗？还是说会等待 <code>commit</code> 成功才返回？</p>
<p>📝答：必须等<code>commit</code>完成后</p>
<p> </p>
<hr>
<p> </p>
<h2 id="四-redo-log">四、 redo log</h2>
<p> </p>
<p> </p>
<h3 id="41-孔乙己的启示">4.1 孔乙己的启示</h3>
<p> </p>
<p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录</p>
<p>(1) 如果赊账的人不多，那么他可以把顾客名和账目写在板上</p>
<p>(2) 但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本</p>
<p> </p>
<p>如果有人要赊账或者还账的话，掌柜一般有两种做法:</p>
<p>(1) 一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉</p>
<p>(2) 另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算</p>
<p> </p>
<p>在生意红火柜台很忙时，掌柜一定会选择后者，先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受?</p>
<p>同样，在 <code>MySQL</code> 里也有这个问题</p>
<p> </p>
<p>如果每一次的更新操作都需要写进磁盘，</p>
<p>然后磁盘也要找到对应的那条记录，然后再更新，整个过程 <code>IO</code> 成本、查找成本都很高</p>
<p>为了解决这个问题，<code>MySQL</code> 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率</p>
<p> </p>
<h3 id="42-wal-技术">4.2 WAL 技术</h3>
<p> </p>
<p>粉板和账本配合的整个过程，其实就是 <code>MySQL</code> 里经常说到的 <code>WAL </code>技术</p>
<p><code>WAL</code> 的全称是 <code>write-ahead logging</code>, 它的关键点就是: 先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本</p>
<p><code>WAL</code>是指在“数据真正写入对应的磁盘数据页“ 之前写日志</p>
<p> </p>
<p>具体来说，当有一条记录需要更新的时候</p>
<p>(1) <code>InnoDB</code> 引擎就会先把记录写到 <code>redo log</code>（粉板）里面，并更新内存，这个时候更新就算完成了</p>
<p>(2) <code>InnoDB </code>引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事</p>
<p> </p>
<p>🔖问： 如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？</p>
<p>📝答： 这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间</p>
<p> </p>
<h3 id="43--写入模式">4.3  写入模式</h3>
<p> </p>
<p><code>InnoDB</code> 的 <code>redo log</code> 是固定大小的，</p>
<p>比如可以配置为一组 <code>4</code> 个文件，每个文件的大小是 <code>1GB</code>，那么这块“粉板”总共就可以记录 <code>4GB</code> 的操作。</p>
<p>从头开始写，写到末尾就又回到开头循环写</p>
<p> </p>
<p>🔖问：“<code>redo log</code> 可以是<code>4组文件</code>，每个文件大小<code>1G</code>”，从大并发<code>update</code>性能方面考虑，这个文件大小及几组一般怎样配置比较合适?</p>
<p>📝答：我觉得如果是<code>1T</code>以上的磁盘&amp;不小于<code>64G</code>的内存，都可以按照<code>4*1G</code>来配置<code>redo log</code></p>
<p> </p>
<h4 id="431-write-pos">4.3.1 write pos</h4>
<p> </p>
<p><code>write pos</code> 是当前记录的位置, 一边写一边后移，写到最后一个文件末尾后就回到 第一个文件开头</p>
<p> </p>
<h4 id="432-checkpoint">4.3.2 checkpoint</h4>
<p> </p>
<p><code>checkpoint</code> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件</p>
<p> </p>
<h4 id="433-中间部分">4.3.3 中间部分</h4>
<p> </p>
<p><code>write pos</code> 和 <code>checkpoint</code> 之间的是“粉板”上还空着的部分，可以用来记录新的操作</p>
<p>如果 <code>write pos </code>追上 <code>checkpoint</code>，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 <code>checkpoint</code> 推进一下</p>
<p> </p>
<p>🔖问：<code>WAL</code>可以保证之前提交的记录不会丢失。所以是不是只能是<code>checkpoint</code>过的记录不会丢失呢？</p>
<p>那没有<code>checkpoint</code>过的数据但是已经<code>write</code>到<code>redo log</code>里的，在数据库发生问题了，应该都丢失了吧。</p>
<p>如果发生这样的问题，如何恢复呢？</p>
<p>📝答：不会呀，崩溃恢复的时候，会从<code>checkpoint</code>开始往后主动去刷数据的，没有<code>checkpoint</code>过的并不会丢失，只是崩溃恢复的时候花点时间</p>
<p> </p>
<h4 id="434-crash-safe">4.3.4 crash-safe</h4>
<p> </p>
<p>有了 <code>redo log</code>，<code>InnoDB </code>就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <code>crash-safe</code></p>
<p>要理解 <code>crash-safe</code> 这个概念，可以想想我们前面赊账记录的例子:</p>
<p> </p>
<p>只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目</p>
<p> </p>
<h3 id="44-redolog的总结">4.4 redolog的总结</h3>
<p> </p>
<p>物理日志 <code>redo log</code>用于保证 <code>crash-safe</code> 能力</p>
<p><code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 <code>1</code> 的时候，表示每次事务的 <code>redo log</code> 都直接持久化到磁盘</p>
<p>这个参数我建议你设置成 <code>1</code>，这样可以保证 <code>MySQL</code> 异常重启之后数据不丢失</p>
<p> </p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql">
<span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s2">&#34;innodb_flush_log_at_trx_commit&#34;</span><span class="p">;</span>

<span class="c1"># 返回值
</span><span class="c1"></span><span class="o">+--------------------------------+-------+</span>
<span class="o">|</span> <span class="n">Variable_name</span>                  <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+--------------------------------+-------+</span>
<span class="o">|</span> <span class="n">innodb_flush_log_at_trx_commit</span> <span class="o">|</span> <span class="mi">1</span>     <span class="o">|</span>
<span class="o">+--------------------------------+-------+</span>

</code></pre></div><p> </p>
<p>🔖问： 看上去数据库正常关闭会清空<code>redolog</code>？</p>
<p>📝答：不会， 就算事务放弃了，<code>redolog</code>也留着，<code>redolog</code>循环写的，下次循环回来就覆盖掉了</p>
<p> </p>
<p>🔖问：如果两种<code>log</code>都写完成了，但是<code>redolog</code>没有写磁盘，物理机挂了，<code>redolog</code>在内存中就丢失了吧，再启动跟磁盘中的<code>binlog</code>就不一致，后期恢复数据的时候会有问题吧？</p>
<p>📝答：是的，这就是<code>trx_commit</code>没设置成<code>1</code>的后果</p>
<p> </p>
<p>🔖问：既然<code>write pos</code>和<code>checkout</code>都是往后推移并循环的，而且当<code>write pos</code>赶上<code>checkout</code>的时候要停下来，将<code>checkout</code>往后推进，</p>
<p>是不是意味着，后续的更新请求都会等待，等<code>checkout</code>往后推到一定空间后，再继续执行？</p>
<p>如果上述成立的话，在大量的更新或插入操作的时候，</p>
<p><code>write pos</code>可能会很快的追上<code>checkout</code>，从而再次产生等待的过程，这个是不是一个在性能上产生瓶颈？</p>
<p>📝答：是的，所以</p>
<p>（1）要设置大一点的<code>innodb redolog</code>的大小</p>
<p>（2）用好点的磁盘</p>
<p> </p>
<p>🔖问：在一个大事务或长事务里，一边执行<code>sql</code>一边写<code>redo log</code>吗？未提交的事物也会写到<code>redo log file</code>吗？</p>
<p>📝答：会先写一块内存，叫做<code>log_buffer</code>里面，在提交的时候再一次性写到磁盘</p>
<p> </p>
<p>🔖问： 请问<code>redo log</code>等系统不忙更新数据的时候，也是需要先从磁盘读出数据到内存，然后用<code>redolog</code>里面的记录更新内存，最后再一起写入磁盘吗？</p>
<p>📝答： 对，这个就是“推进<code>checkpoint</code>”的过程; 当然也有可能<code>redo log</code>要更新的那个数据页刚好在内存，就跳过了你说的第一步</p>
<p> </p>
<hr>
<p> </p>
<h2 id="五-binlog">五、 binlog</h2>
<p> </p>
<p><code>MySQL</code> 整体来看，其实就有两块：</p>
<p>一块是 <code>Server</code> 层，它主要做的是 <code>MySQL </code>功能层面的事情</p>
<p>还有一块是引擎层，负责存储相关的具体事宜</p>
<p> </p>
<p>(1) <code>redo log</code> 是 <code>InnoDB</code> 引擎特有的日志</p>
<p>(2) <code>Server</code> 层也有自己的日志，称为 <code>binlog</code>（归档日志）</p>
<p> </p>
<h3 id="51-为什么会有两份日志呢">5.1 为什么会有两份日志呢?</h3>
<p> </p>
<p>因为最开始 <code>MySQL</code> 里并没有 <code>InnoDB</code> 引擎</p>
<p><code>MySQL</code> 自带的引擎是 <code>MyISAM</code>，但是 <code>MyISAM</code> 没有 <code>crash-safe</code> 的能力，<code>binlog</code> 日志只能用于归档</p>
<p>而 <code>InnoDB</code> 是另一个公司（<code>Innobase</code>， 一家芬兰的公司，已经被<code>Oracle</code>收购）以插件形式引入 <code>MySQL</code> 的</p>
<p>既然只依靠 <code>binlog</code> 是没有 <code>crash-safe</code> 能力的，所以 <code>InnoDB</code> 使用另外一套日志系统——也就是 <code>redo log</code> 来实现 <code>crash-safe</code> 能力</p>
<p> </p>
<h3 id="52-binlog-和-redolog的不同之处">5.2 binlog 和 redolog的不同之处</h3>
<p> </p>
<p>(1) <code>redo log</code> 是<code>InnoDB</code>引擎特有的,</p>
<p><code>binlog</code> 是 <code>MySQL </code>的<code>Server</code>层实现的，所有引擎都可以使用</p>
<p> </p>
<p>(2) <code>redo log</code> 是物理日志, 记录的是“在某个数据页上做了什么修改”;</p>
<p><code>binlog</code> 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 <code>ID=2</code> 这一行的 <code>c </code>字段加 <code>1</code> &quot;</p>
<p> </p>
<p>🔖问： <code>binlog</code>为什么说是逻辑日志呢？它里面有内容也会存储成物理文件，怎么说是逻辑而不是物理？</p>
<p>📝答： 逻辑日志可以给别的数据库，别的引擎使用，已经大家都讲得通这个“逻辑”； 物理日志就只有“我”自己能用，别人没有共享我的“物理格式”</p>
<p> </p>
<p>(3) <code>redo log</code> 是循环写的，空间固定会用完;</p>
<p><code>binlog</code> 是可以追加写入的。“追加写”是指 <code>binlog</code> 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</p>
<p> </p>
<p>🔖问：如果把<code>redo log</code>归档不就可以了吗？</p>
<p>📝答：这个就是物理复制了，属于比较新的方向，现在官方还没有哈</p>
<p> </p>
<p>🔖问：可以认为<code>redo log</code> 记录的是这个行在这个页更新之后的状态，<code>binlog</code> 记录的是<code>sql</code>吗？</p>
<p> </p>
<p>📝答：<code>Redo log</code>不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动</p>
<p><code>Binlog</code>有两种模式，<code>statement </code>格式的话是记<code>sql</code>语句， <code>row</code>格式会记录行的内容，记两条，更新前和更新后都有</p>
<p> </p>
<p> </p>
<p>🔖问： 既然已经有了<code>redolog</code>, <code>binlog</code>是否是多余的呢？</p>
<p> </p>
<p>📝答： <code>binlog</code>还不能去掉。一个原因是，<code>redolog</code>只有<code>InnoDB</code>有，别的引擎没有。另一个原因是，<code>redolog</code>是循环写的，不持久保存，<code>binlog</code>的“归档”这个功能，<code>redolog</code>是不具备的</p>
<p> </p>
<p>🔖问： <code>redolog</code> 用于<code>crash</code>的恢复，而<code>binlog</code>用于库的恢复，两者是否在某种程度上是重复的？</p>
<p>📝答：（1）<code>Crash-safe</code>是崩溃恢复，就是原地满血复活； （2）<code>binlog</code>恢复是制造一个影分身（副本）出来</p>
<p> </p>
<p>🔖问： <code>redo log</code>和<code>bin log</code>怎么对应？</p>
<p>📝答：事务<code>ID</code></p>
<p> </p>
<h3 id="53-内部更新流程">5.3 内部更新流程</h3>
<p> </p>
<p> </p>
<h4 id="531--执行器从引擎中获取记录">5.3.1  执行器从引擎中获取记录</h4>
<p> </p>
<p>执行器先找引擎取 <code>ID=2</code> 这一行, <code>ID</code> 是主键，引擎直接用树搜索找到这一行</p>
<p>如果 <code>ID=2</code> 这一行所在的数据页本来就在内存中，就直接返回给执行器</p>
<p>否则，需要先从磁盘读入内存，然后再返回。</p>
<p> </p>
<p>🔖问：关于提到的&rsquo;数据页&rsquo;这个词我没有太理解，是一种存储方式么？</p>
<p>📝答：<code>MySQL</code>的记录是以<code>“页”</code>为单位存取的，默认大小<code>16K</code>。也就是说，你要访问磁盘中一个记录，不会只读这个记录，而会把它所在的<code>16K</code>数据一起读入内存</p>
<p> </p>
<h4 id="532-执行器执行更新">5.3.2 执行器执行更新</h4>
<p> </p>
<p>执行器拿到引擎给的行数据，把这个值加上 <code>1</code>，比如原来是 <code>N</code>，现在就是 <code>N+1</code>，得到新的一行数据，再调用引擎接口写入这行新数据</p>
<p> </p>
<h4 id="533-redo-log更新">5.3.3 redo log更新</h4>
<p> </p>
<p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 <code>redo log</code> 里面，</p>
<p>此时 <code>redo log</code> 处于 <code>prepare</code> 状态。</p>
<p>然后告知执行器执行完成了，随时可以提交事务</p>
<p> </p>
<p>🔖问： 写<code>redolog</code>也是写<code>io</code>， 同样耗费性能。怎么能做到优化呢？</p>
<p>📝答： （1）<code>Redolog</code>是顺序写, ，不用去“找位置”，而更新数据需要找位置； （2）组提交； （3）其他优化</p>
<p> </p>
<p> </p>
<h4 id="534-binlog更新">5.3.4 binlog更新</h4>
<p> </p>
<p>执行器生成这个操作的 <code>binlog</code>，并把 <code>binlog</code> 写入磁盘</p>
<p> </p>
<h4 id="535-提交事务">5.3.5 提交事务</h4>
<p> </p>
<p>执行器调用引擎的提交事务接口，引擎把刚刚写入的 <code>redo log</code> 改成提交（<code>commit</code>）状态，更新完成</p>
<p> </p>
<p>🔖问： 数据库只有<code>redo commit</code> 之后才会真正提交到数据库吗？</p>
<p>📝答： 正常执行是要<code>commit</code> 才算完，，但是崩溃恢复过程的话，可以接受&quot;<code>redolog prepare</code> 并且<code>binlog</code>完整” 的情况</p>
<p> </p>
<p>🔖问：如上，<code>mysql</code>可以接受<code>redolog prepare</code> 并且<code>binlog</code>完整场景下， <code>commit</code>执行，崩溃恢复，那么，最后一步的<code>commit</code>也可以不存在呀？</p>
<p>📝答：最后一步<code>commit</code>还是非常有用的，如果<code>redolog</code> 已经<code>commit</code>了，崩溃恢复就不需要去找<code>binlog</code></p>
<p> </p>
<p>🔖问： 响应一次<code>SQL</code>我理解是要同时操作两个日志文件？也就是写磁盘两次？</p>
<p>📝答： 其实是<code>3次</code>（<code>redolog</code>两次, <code>binlog</code> 1次）。不过在并发更新的时候会合并写</p>
<p> </p>
<p>🔖问：<code>redo log</code>和 <code>binlog</code> 也是需要写文件的，也会消耗<code>IO</code>，这个不会影响数据库的性能吗？</p>
<p>📝答： 要写<code>IO</code>，是会影响，但是为了数据可靠性，还是要做的</p>
<p> </p>
<p>🔖问： 从内容看<code>redo log</code>首先写入缓存中，如果这个时候断电了，缓存也清空了，尚未写入磁盘，这个时候<code>redo log</code> 是不完整的，如何保证恢复的完整性呢？</p>
<p>📝答：<code>Redolog</code>是直接写盘的，更新的内存是数据的内存; 如果没有写完就重启，就回滚，不算丢数据</p>
<p> </p>
<p>🔖问： 执行一条<code>Update</code> 语句后，马上又执行一条 <code>select * from table limit 10</code>，</p>
<p>如果刚刚<code>update</code>的记录，还没持久化到磁盘中，而偏偏这个时候的查询条件，又包含了刚刚<code>update</code>的记录；</p>
<p>那么这个时候，是从日志中获取刚刚<code>update</code>的最新结果，</p>
<p>还是说，先把日志中的记录先写磁盘，再返回最新结果？</p>
<p>📝答： 都不是，直接读内存， 如上<code>5.3.3</code>， 更新数据会在内存中</p>
<p>首先数据库更新操作都是基于内存页, 更新的时候不会直接更新磁盘，</p>
<p>如果内存有存在就直接更新内存，</p>
<p>如果内存没有存在就从磁盘读取到内存，在更新内存</p>
<p> </p>
<p>🔖问： 关于上面数据页在内存中， 有下面的疑问？</p>
<p>A. 假如我要更新<code>type='xiaomi'</code>(可能有有<code>100W</code>条)数据。那么这些数据是否都要加载到内存中吗？</p>
<p>B. 假如我要查询 <code>type='xiaomai' and location='beijing'</code>,那么这条数据获取时候从内存中获取的吗？</p>
<p>C. 更新数据条数是不是有一个上限？</p>
<p>D. 是不是每次启动<code>mysql</code>它都会检查一次先前有没有异常未提交成功的事务呢？</p>
<p>📝答：</p>
<p>A. 如果你的语句是<code>where type='xiaomi'</code>, 是肯定会的</p>
<p>B. 所有的查数据都是从内存读的，只是说如果还没在内存里，要从磁盘读到内存中</p>
<p>C. 没有上限</p>
<p>D. 会的，就是<code>crash recovery</code>过程</p>
<p> </p>
<h3 id="54-redolog的两阶段提交">5.4 redolog的两阶段提交</h3>
<p> </p>
<p> </p>
<h4 id="541-为什么必须有两阶段提交呢">5.4.1 为什么必须有“两阶段提交”呢?</h4>
<p> </p>
<p>这是为了让两份日志之间的逻辑一致</p>
<p> </p>
<h4 id="542-怎样让数据库恢复到半个月内任意一秒的状态">5.4.2 怎样让数据库恢复到半个月内任意一秒的状态?</h4>
<p> </p>
<p><code>binlog</code> 会记录所有的逻辑操作，并且是采用“追加写”的形式</p>
<p>如果你的 <code>DBA</code> 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 <code>binlog</code>，同时系统会定期做整库备份。</p>
<p>这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备</p>
<p> </p>
<p>🔖问：怎样让数据库恢复到半个月内任意一秒的状态？这个是不是还需要<code>redo log</code>啊？为啥我感觉仅仅<code>binlog</code>不够</p>
<p>📝答：<code>binlog</code>记录了所有操作，操作记录里的时间也是精确到秒的</p>
<p> </p>
<p>🔖问：如果有主从配置， 是不是就不需要备份了？</p>
<p>📝答：要，错误执行的<code>drop table</code> 也会同步给备库的</p>
<p> </p>
<h4 id="543-恢复数据的过程">5.4.3 恢复数据的过程</h4>
<p> </p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p>
<p>(1) 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库;</p>
<p>(2) 然后，从备份的时间点开始，将备份的 <code>binlog</code> 依次取出来，重放到中午误删表之前的那个时刻</p>
<p>(3) 这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去</p>
<p> </p>
<h4 id="544-如果不使用两阶段提交">5.4.4 如果不使用两阶段提交？</h4>
<p> </p>
<p>用前面的 <code>update</code> 语句来做例子，</p>
<p>(1) 假设当前 <code>ID=2</code> 的行，字段 <code>c</code> 的值是 <code>0</code>，</p>
<p>(2) 再假设执行 <code>update</code> 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 <code>crash</code>，</p>
<p>会出现什么情况呢？</p>
<p> </p>
<p>(1) 先写 <code>redo log</code> 后写 <code>binlog</code></p>
<p> </p>
<p>假设在 <code>redo log</code> 写完，<code>binlog</code> 还没有写完的时候，<code>MySQL</code> 进程异常重启;</p>
<p>A. 由于我们前面说过的，<code>redo log </code>写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 <code>c </code>的值是 <code>1</code>;</p>
<p>B. 但是由于 <code>binlog</code> 没写完就 <code>crash</code> 了，这时候 <code>binlog</code> 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 <code>binlog</code> 里面就没有这条语句</p>
<p>然后你会发现，如果需要用这个 <code>binlog</code> 来恢复临时库的话，由于这个语句的 <code>binlog</code> 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 <code>c </code>的值就是 <code>0</code>，与原库的值不同</p>
<p> </p>
<p>(2) 先写 <code>binlog</code> 后写 <code>redo log</code></p>
<p> </p>
<p>如果在 <code>binlog</code> 写完之后 <code>crash</code></p>
<p>A. 由于 <code>redo log</code> 还没写，崩溃恢复以后这个事务无效，所以这一行 <code>c </code>的值是 <code>0</code></p>
<p>B. 但是 <code>binlog</code> 里面已经记录了“把 <code>c</code> 从 <code>0</code> 改成 <code>1</code>”这个日志。所以，在之后用 <code>binlog</code> 来恢复的时候就多了一个事务出来，恢复出来的这一行 <code>c</code> 的值就是 <code>1</code></p>
<p>与原库的值不同</p>
<p>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</p>
<p> </p>
<p>🔖问：  <code>redo log</code>写入内存的数据，是跟各个事务绑定的，</p>
<p>假设 <code>ID</code>为<code>2</code>的数据<code>c=1</code>，执行更新语句 <code>update T set c=c+1 where ID=2</code>;</p>
<p>在更新语句执行过程中，写入了<code>redo log</code>，但未两阶段提交。</p>
<p>此时，是不是只有当前事务才能读取到<code>c=2?</code></p>
<p>即便写到磁盘，磁盘的数据，是否也有事务版本信息来保障？</p>
<p>📝答： 是的，这个事务还没有提交，没有提交的事务的更新，对其他事务是不可见的；</p>
<p>是的，一个数据行的<code>trx_id</code>是一个数据的一部分，写磁盘的时候也是带着的</p>
<p> </p>
<p>🔖问：是不是磁盘中的数据也有事务<code>id</code>，这样如果写完<code>redolog</code>，内存中的数据还没刷到磁盘，系统奔溃重启后可以用<code>redolog</code>来检查当前数据是不是最新的用来恢复?</p>
<p>📝答：是的，<code>trx_id</code>是数据的一个字段，会持久化到磁盘</p>
<p> </p>
<p> </p>
<h4 id="545-总结两阶段提交">5.4.5 总结两阶段提交</h4>
<p> </p>
<p>三个步骤：</p>
<p>(1) <code>redolog prepare</code>阶段</p>
<p>(2) 写<code>binlog</code></p>
<p>(3) <code>redo log commit</code>阶段</p>
<p> </p>
<p><code>场景一</code>、在<code>(2)</code>之前崩溃，即<code>binlog</code>没有写入</p>
<p><code>mysql</code>重启恢复时候，会发现没有<code>commit</code>, 回滚<code>redolog</code>,</p>
<p>备份恢复时候，没有<code>binlog</code>记录， 和回滚后的<code>redolog</code>  保持一致；</p>
<p> </p>
<p>🔖问：写<code>redo log</code>处于<code>prepare</code>阶段后，如果写<code>binlog</code>失败是会回滚<code>redo log</code>的记录吗？</p>
<p>📝答：不用回滚日志，只需要打上<code>“rollback”</code>标签</p>
<p> </p>
<p><code>场景二</code>、在(3)之前崩溃，即<code>binlog</code>已经写入，但是没有<code>commit</code></p>
<p><code>mysql</code>重启恢复， 虽然没有<code>commit</code>, 但是满足<code>prepare</code> 和  <code>binlog</code>完整，所以重启后会自动<code>commit</code> ,</p>
<p>备份恢复时候，有<code>binlog</code>记录，和<code>commit</code>后的<code>redolog</code> 保持一致</p>
<p> </p>
<p>🔖问： 两阶段提交是原子性的吧？</p>
<p>📝答： 不是，如果保证原子性，就不用两阶段</p>
<p> </p>
<p>🔖问：执行最后<code>commit</code>，<code>innodb</code>的<code>commit</code>具体是做了哪些操作呀？移动<code>checkpoint</code>指针吗？</p>
<p>📝答：不是，<code>Redolog</code>上打上<code>commit</code> 标签，写盘</p>
<p> </p>
<p>🔖问：当<code>mysql</code>重启，对于<code>innodb</code>的启动是如何实现的？听文章说<code>redo log</code>会很大，比如<code>1G</code>，需要全都加载一遍才能算启动完成吗？</p>
<p>📝答：从<code>checkpoint</code>开始到<code>writepos</code>结束，不需要全部<code>1G</code>, 即全部大小<code>1G</code> 减去 可以写入的空间（从<code>writepos</code>到<code>checkpoint</code>)</p>
<p> </p>
<p>🔖问：<code>checkpoint</code>是指<code>redo buffer</code>落盘的位置，还是指日志更新写到表中的位置（<code>crash recovery</code>的起始点）</p>
<p>📝答：<code>Write pos</code>是<code>redo buffer</code>接下来要写的位置， <code>crash recovery</code> 的起点就是<code>checkpoint</code></p>
<p> </p>
<p>🔖问：在<code>binlog</code>写入磁盘后，<code>commit</code>提交前发生<code>crash</code>，由于<code>commit</code>没有成功，那返回给客户端的消息是事物失败，</p>
<p>但是在系统恢复的时候却会重新提交事物，使之成功，这不是在欺骗客户端嘛？问题很大啊</p>
<p>📝答：不是，并没有返回“事务失败”呀，而是<code>“执行异常”</code>； 执行异常本来就可能成功也可能失败的。</p>
<p>你想一下这个场景：执行全部完成了，在回复客户端的时候网络断了，这怎么算</p>
<p> </p>
<p>🔖问：同上，但是如果业务系统请求认为数据库异常，</p>
<p>所以业务系统认为此次处理未生效，告知其他业务系统，那么其他业务系统再次提交请求，</p>
<p>是不是就造成了重复提交的问题？</p>
<p>在平时业务系统应该怎么处理这类情况？</p>
<p>📝答：&ldquo;但是如果业务系统请求认为数据库异常，所以业务系统认为此次处理未生效，&rdquo;</p>
<p>不应该这么认为，如果业务系统这么认为，那属于业务系统的<code>bug</code>; 正常应该是等重连成功以后再查一次，去确认事务状态</p>
<p> </p>
<p>🔖问： 在<code>redo log commit</code>的时候，是追加写呢，还是找到<code>prepare</code>的地方进行修改呢？</p>
<p>📝答： <code>prepare</code>写日志的最后一个<code>512字节</code>，会在<code>commit</code>的时候被改掉</p>
<p> </p>
<p>🔖问：如果没有开启<code>binlog</code>的更新操作是怎么样的？是否也有两段提交？</p>
<p>📝答：就只有<code>redo</code>，没有两阶段了</p>
<p> </p>
<h3 id="55-恢复临时库的场景">5.5 恢复临时库的场景</h3>
<p> </p>
<p> </p>
<h4 id="551-误操作">5.5.1 误操作</h4>
<p> </p>
<p>误操作后需要用这个过程来恢复数据</p>
<p> </p>
<h4 id="552-扩容">5.5.2 扩容</h4>
<p> </p>
<p>当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，</p>
<p>现在常见的做法也是用全量备份加上应用 <code>binlog</code> 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况</p>
<p>简单说，<code>redo log</code> 和 <code>binlog</code> 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致</p>
<p> </p>
<p> </p>
<p>🔖问： 这两种日志可以在哪直观查看？</p>
<p>📝答：都是文件，在数据库的<code>data</code>目录下，默认的，<code>redolog</code>是<code>ib_log_file0</code>这样的，<code>binlog</code>是<code>xxx-bin.000001</code>这样的</p>
<p> </p>
<h3 id="56-binlog总结">5.6 binlog总结</h3>
<p> </p>
<p>逻辑日志 <code>binlog</code>通常用于备份临时库，</p>
<p><code>sync_binlog</code> 这个参数设置成 <code>1</code> 的时候，表示每次事务的 <code>binlog</code> 都持久化到磁盘</p>
<p>这个参数我也建议你设置成 <code>1</code>，这样可以保证 <code>MySQL</code> 异常重启之后 <code>binlog</code> 不丢失</p>
<p> </p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s2">&#34;sync_binlog&#34;</span><span class="p">;</span>

<span class="c1"># 返回值
</span><span class="c1"></span><span class="o">+---------------+-------+</span>
<span class="o">|</span> <span class="n">Variable_name</span> <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+---------------+-------+</span>
<span class="o">|</span> <span class="n">sync_binlog</span>   <span class="o">|</span> <span class="mi">1</span>     <span class="o">|</span>
<span class="o">+---------------+-------+</span>

</code></pre></div><p> </p>
<p> </p>
<p>🔖问： 怎么知道<code>binlog</code>是完整的？</p>
<p>📝答： 一个事务的完整<code>binlog</code>是有固定格式，也就是说有固定结尾的</p>
<p> </p>
<p>🔖问： <code>redo</code> 和 <code>binlog</code>是在内存中还是磁盘？要是在磁盘上每次写的时候会不会影响性能？还是内存和磁盘上都有？如果都有的话怎么保持在突然断电的时候数据一致性？</p>
<p>📝答： <code>redo log</code>有<code>redo log buffer</code>; <code>binlog </code>有<code>binlog cache</code>； 保持数据一致性的问题，后面涉及到</p>
<p> </p>
<p>🔖问： <code>innodb_flush_log_at_trx_commit</code>如果设置成<code>1</code>而<code>sync_binlog</code>未设置成<code>1</code>，这个时候如果执行完<code>redo log</code>后宕机了，是不是<code>redo log</code>的内容跟<code>binlog</code>也会不一样？</p>
<p>📝答：对，有可能</p>
<p> </p>
<p>🔖问：两个控制日志写磁盘的性能参数 如果都设置<code>1</code> 会不会对<code>io</code>影响很大 对大并发也要设成<code>1</code>吗？</p>
<p>📝答：一般这两个都建议设置成<code>1</code>（有时候称<code>双1</code>），除非你的系统<code>IO</code>撑不住了要临时应急</p>
<p> </p>
<p>🔖问：<code>binlog</code>感觉像<code>oracle</code>的归档日志，那么也有设置<code>binlog</code>日期的参数，这个参数是？默认值又是多少？</p>
<p>📝答：<code>expire_logs_days</code>， 默认是<code>0</code> 表示不自动删除；非零的话，单位是天</p>
<p> </p>
<hr>
<p> </p>
<h2 id="六涉及参数">六、涉及参数</h2>
<p> </p>
<p> </p>
<h3 id="61-binlog_format">6.1 binlog_format</h3>
<p> </p>
<p><code>binlog_format</code>,</p>
<p><code>binlog</code>的类型，可选值为 <code>STATEMENT/ ROW/ MIXED</code></p>
<p> </p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># (1) 查看binlog日志格式
</span><span class="c1"></span><span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s2">&#34;binlog_format&#34;</span>

<span class="c1"># 返回值
</span><span class="c1"></span><span class="o">+---------------+-------+</span>
<span class="o">|</span> <span class="n">Variable_name</span> <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+---------------+-------+</span>
<span class="o">|</span> <span class="n">binlog_format</span> <span class="o">|</span> <span class="n">ROW</span>   <span class="o">|</span>
<span class="o">+---------------+-------+</span>

<span class="c1"># (2) 更新binlog日志格式
</span><span class="c1"></span><span class="kt">SET</span> <span class="n">GLOBAL</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="s1">&#39;STATEMENT&#39;</span><span class="p">;</span>

<span class="kt">SET</span> <span class="n">GLOBAL</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="s1">&#39;ROW&#39;</span><span class="p">;</span>

<span class="kt">SET</span> <span class="n">GLOBAL</span> <span class="n">binlog_format</span> <span class="o">=</span> <span class="s1">&#39;MIXED&#39;</span><span class="p">;</span>
</code></pre></div><p> </p>
<p> </p>
<h3 id="62-sync_binlog">6.2 sync_binlog</h3>
<p> </p>
<p><code>sync_binlog</code>, 控制<code>MySQL</code>服务器将<code>binlog</code>同步到磁盘的频率， 可选值为 <code>0/1/N</code></p>
<p> </p>
<p>(1) 值为<code>0</code>时候，禁用<code>MySQL</code>服务器将<code>binlog</code>同步到磁盘的功能, 取而代之的是，</p>
<p><code>MySQL</code>服务器依靠操作系统不时将<code>binlog</code>刷新到磁盘上，就像处理其他任何文件一样。</p>
<p>此设置提供最佳性能，但是在电源故障或操作系统崩溃的情况下，服务器可能提交了尚未同步到<code>binlog</code>的事务</p>
<p> </p>
<p>(2) 值为<code>1</code>时候，在提交事务之前启用<code>binlog</code>到磁盘的同步。</p>
<p>这是最安全的设置，但由于磁盘写入次数增加，可能会对性能产生负面影响。</p>
<p>如果发生电源故障或操作系统崩溃，<code>binlog</code>缺少的事务将仅处于准备状态。</p>
<p>这允许自动恢复例程回滚事务，从而保证<code>binlog</code>中不会丢失任何事务</p>
<p> </p>
<p>(3) 值为<code>N</code>的时候（<code>N</code>不等于<code>0</code>或者<code>1</code>），<code>N</code>次<code>binlog</code>提交组已收集之后，<code>binlog</code>将同步到磁盘 。</p>
<p>在电源故障或操作系统崩溃的情况下，服务器可能提交了尚未刷新到<code>binlog</code>的事务。</p>
<p>由于磁盘写入次数的增加，此设置可能会对性能产生负面影响。</p>
<p>较高的值可以提高性能，但是会增加数据丢失的风险</p>
<p> </p>
<p> </p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># (1) 查看当前的配置
</span><span class="c1"></span>
<span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s2">&#34;sync_binlog&#34;</span><span class="p">;</span>

<span class="c1"># 返回值
</span><span class="c1"></span>
<span class="o">+---------------+-------+</span>
<span class="o">|</span> <span class="n">Variable_name</span> <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+---------------+-------+</span>
<span class="o">|</span> <span class="n">sync_binlog</span>   <span class="o">|</span> <span class="mi">1</span>     <span class="o">|</span>
<span class="o">+---------------+-------+</span>

</code></pre></div><p> </p>
<p> </p>
<h3 id="63-innodb_flush_log_at_trx_commit">6.3 innodb_flush_log_at_trx_commit</h3>
<p> </p>
<p><code>innodb_flush_log_at_trx_commit</code>， 表示<code>redo log</code>文件持久化的方式，可选值为 <code>0/1/2</code></p>
<p> </p>
<p>(1) 默认值是<code>1</code>， 实现<code>ACID</code>， 每次事务提交， 都会确保<code>redo log</code>里的数据是持久化到磁盘的</p>
<p>每次事务提交时，<code>log buffer</code> 会被写入到日志文件并刷写到磁盘。这也是默认值。</p>
<p>这是最安全的配置，但由于每次事务都需要进行磁盘<code>I/O</code>，所以也<code>最慢</code></p>
<p> </p>
<p>(2) 如果值是<code>2</code>， 其实只是“写到<code>redo log</code>文件，但是没有持久化(<code>fsync</code>)”</p>
<p>当取值为 <code>2</code> 时，每次事务提交会写入日志文件，但并不会立即刷写到磁盘，日志文件会<code>每秒</code>刷写一次到磁盘。</p>
<p>这时如果 <code>mysqld</code> 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；</p>
<p>在操作系统崩溃的情况下，通常会导致最后 <code>1s</code> 的日志丢失</p>
<p> </p>
<p>(3) 如果取值为<code> 0</code> 的时候，<code>log buffer</code> 会 每秒写入到日志文件并刷写（<code>flush</code>）到磁盘</p>
<p>但每次事务提交不会有任何影响，也就是 <code>log buffer </code>的刷写操作和事务提交操作没有关系。</p>
<p>在这种情况下，<code>MySQL</code>性能<code>最好</code>，</p>
<p>但如果 <code>mysqld</code> 进程崩溃，通常会导致最后 <code>1s</code> 的日志丢失</p>
<p> </p>
<p>(4) 上面说到的「<code>最后 1s</code>」并不是绝对的，有的时候会丢失更多数据。</p>
<p>有时候由于调度的问题，每秒刷写（<code>once-per-second flushing</code>）并不能保证 <code>100%</code> 执行。</p>
<p>对于一些数据一致性和完整性要求不高的应用，配置为<code>2</code>就足够了；</p>
<p>如果为了最高性能，可以设置为 <code>0</code>。</p>
<p>有些应用，如支付服务，对一致性和完整性要求很高，所以即使最慢，也最好设置为<code> 1</code>.</p>
<p> </p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># (1) 查看当前的redolog持久化方式
</span><span class="c1"></span>
<span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s2">&#34;innodb_flush_log_at_trx_commit&#34;</span><span class="p">;</span>

<span class="o">+--------------------------------+-------+</span>
<span class="o">|</span> <span class="n">Variable_name</span>                  <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+--------------------------------+-------+</span>
<span class="o">|</span> <span class="n">innodb_flush_log_at_trx_commit</span> <span class="o">|</span> <span class="mi">1</span>     <span class="o">|</span>
<span class="o">+--------------------------------+-------+</span>

</code></pre></div><p> </p>
<p> </p>
<h3 id="64-expire_logs_daysbinlog_expire_logs_seconds">6.4 expire_logs_days/binlog_expire_logs_seconds</h3>
<p> </p>
<p><code>expire_logs_days</code>,</p>
<p><code>binlog</code>保存的天数，超过该数值将删除， 可选值为<code>0 ~ 99</code></p>
<p> </p>
<p>(1) 值为<code>0</code>时候，表示“ 不自动删除”， 即<code>binlog</code>将一直保存</p>
<p> </p>
<p>(2) <code>非0值</code>，表示保存天数，最大值为<code>99</code></p>
<p> </p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># mysql 5.7 
</span><span class="c1"></span>
<span class="c1"># (1) 查看过期日期
</span><span class="c1"></span><span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s2">&#34;expire_logs_days&#34;</span><span class="p">;</span>

<span class="c1"># 返回值
</span><span class="c1"></span><span class="o">+------------------+-------+</span>
<span class="o">|</span> <span class="n">Variable_name</span>    <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+------------------+-------+</span>
<span class="o">|</span> <span class="n">expire_logs_days</span> <span class="o">|</span> <span class="mi">0</span>     <span class="o">|</span>
<span class="o">+------------------+-------+</span>

<span class="c1"># (2) 设置过期时间
</span><span class="c1"></span><span class="kt">set</span> <span class="n">global</span> <span class="n">expire_logs_days</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s2">&#34;expire_logs_days&#34;</span><span class="p">;</span>

<span class="c1"># 返回值， 即最大值为99
</span><span class="c1"></span><span class="o">+------------------+-------+</span>
<span class="o">|</span> <span class="n">Variable_name</span>    <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+------------------+-------+</span>
<span class="o">|</span> <span class="n">expire_logs_days</span> <span class="o">|</span> <span class="mi">99</span>    <span class="o">|</span>
<span class="o">+------------------+-------+</span>

</code></pre></div><p> </p>
<p> </p>
<p>这个参数已经废弃，现在<code>mysql 8.0</code>使用<code>binlog_expire_logs_seconds</code></p>
<p>可选值为<code> 0～4294967295</code></p>
<p> </p>
<p>(1) 值为<code>0</code>时候，表示禁用自动清理<code>binlog</code>；</p>
<p>(2) 默认值为<code>2592000</code>秒，即<code>30天</code></p>
<p> </p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql">
<span class="c1"># mysql 8.0
</span><span class="c1"></span>
<span class="c1"># (1) 查看过期配置
</span><span class="c1"></span><span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s2">&#34;binlog_expire_logs_seconds&#34;</span><span class="p">;</span>

<span class="c1"># 返回值
</span><span class="c1"></span><span class="o">+----------------------------+---------+</span>
<span class="o">|</span> <span class="n">Variable_name</span>              <span class="o">|</span> <span class="n">Value</span>   <span class="o">|</span>
<span class="o">+----------------------------+---------+</span>
<span class="o">|</span> <span class="n">binlog_expire_logs_seconds</span> <span class="o">|</span> <span class="mi">2592000</span> <span class="o">|</span>
<span class="o">+----------------------------+---------+</span>

<span class="c1"># (2) 设置过期时间
</span><span class="c1"></span><span class="kt">set</span> <span class="n">global</span> <span class="n">binlog_expire_logs_seconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s2">&#34;binlog_expire_logs_seconds&#34;</span><span class="p">;</span>

<span class="c1"># 返回值
</span><span class="c1"></span><span class="o">+----------------------------+-------+</span>
<span class="o">|</span> <span class="n">Variable_name</span>              <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+----------------------------+-------+</span>
<span class="o">|</span> <span class="n">binlog_expire_logs_seconds</span> <span class="o">|</span> <span class="mi">0</span>     <span class="o">|</span>
<span class="o">+----------------------------+-------+</span>

</code></pre></div><p> </p>
<p> </p>
<h3 id="65-log_bin">6.5 log_bin</h3>
<p> </p>
<p><code>log_bin</code>, 是否开启<code>binlog</code>功能</p>
<p> </p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># (1) 查看log_bin
</span><span class="c1"></span><span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s2">&#34;log_bin&#34;</span><span class="p">;</span>

<span class="c1"># 返回值
</span><span class="c1"></span><span class="o">+---------------+-------+</span>
<span class="o">|</span> <span class="n">Variable_name</span> <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+---------------+-------+</span>
<span class="o">|</span> <span class="n">log_bin</span>       <span class="o">|</span> <span class="n">OFF</span>   <span class="o">|</span>
<span class="o">+---------------+-------+</span>

<span class="c1"># (2) 配置log_bin
</span><span class="c1"></span><span class="err">该参数无法动态配置，需要在配置文件中指定</span>

</code></pre></div><p> </p>
<hr>
<p> </p>
<h2 id="七问题与解答">七、问题与解答</h2>
<p> </p>
<p> </p>
<h3 id="71-问题">7.1 问题</h3>
<p> </p>
<p>定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。</p>
<p>那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？</p>
<p> </p>
<h3 id="72-解答">7.2 解答</h3>
<p> </p>
<p>(1) 好处是“最长恢复时间”更短, 即一天一备份可以更快的恢复；</p>
<p>(2) 系统的对应指标就是<code>RTO</code>（恢复目标时间）</p>
<p>当然一天一备是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个 <code>RTO</code> 是成本换来的，就需要你根据业务重要性来评估了</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2020-07-06</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/mysql/">mysql</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql/1-sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" class="prev" rel="prev" title="1. sql语句执行过程"><i class="fas fa-angle-left fa-fw"></i>1. sql语句执行过程</a>
            <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql/3-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/" class="next" rel="next" title="3. 事务隔离">3. 事务隔离<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.70.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">yz</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/typeit/typeit.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"gitalk":{"admin":["yzthewind"],"clientID":"8e70465ecd960275a174","clientSecret":"32c54e1095f64e2ac3dcfa4afed2e61d5444bc0d","id":"2020-07-06T11:00:00+08:00","owner":"yzthewind","repo":"blog_gitalk","title":"2. sql更新语句执行过程 "}},"data":{"id-1":"一曲广陵散","id-2":"一曲广陵散"},"typeit":{"cursorChar":null,"cursorSpeed":null,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":null,"speed":null}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
